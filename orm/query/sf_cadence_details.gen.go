// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"strings"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/stc-ds-databricks-go/orm/model"
)

func newSfCadenceDetail(db *gorm.DB, opts ...gen.DOOption) sfCadenceDetail {
	_sfCadenceDetail := sfCadenceDetail{}

	_sfCadenceDetail.sfCadenceDetailDo.UseDB(db, opts...)
	_sfCadenceDetail.sfCadenceDetailDo.UseModel(&model.SfCadenceDetail{})

	tableName := _sfCadenceDetail.sfCadenceDetailDo.TableName()
	_sfCadenceDetail.ALL = field.NewAsterisk(tableName)
	_sfCadenceDetail.ID = field.NewString(tableName, "Id")
	_sfCadenceDetail.AccountC = field.NewString(tableName, "Account__c")
	_sfCadenceDetail.ActiveC = field.NewBool(tableName, "Active__c")

	_sfCadenceDetail.fillFieldMap()

	return _sfCadenceDetail
}

type sfCadenceDetail struct {
	sfCadenceDetailDo

	ALL      field.Asterisk
	ID       field.String
	AccountC field.String
	ActiveC  field.Bool

	fieldMap map[string]field.Expr
}

func (s sfCadenceDetail) Table(newTableName string) *sfCadenceDetail {
	s.sfCadenceDetailDo.UseTable(newTableName)
	return s.updateTableName(newTableName)
}

func (s sfCadenceDetail) As(alias string) *sfCadenceDetail {
	s.sfCadenceDetailDo.DO = *(s.sfCadenceDetailDo.As(alias).(*gen.DO))
	return s.updateTableName(alias)
}

func (s *sfCadenceDetail) updateTableName(table string) *sfCadenceDetail {
	s.ALL = field.NewAsterisk(table)
	s.ID = field.NewString(table, "Id")
	s.AccountC = field.NewString(table, "Account__c")
	s.ActiveC = field.NewBool(table, "Active__c")

	s.fillFieldMap()

	return s
}

func (s *sfCadenceDetail) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := s.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (s *sfCadenceDetail) fillFieldMap() {
	s.fieldMap = make(map[string]field.Expr, 3)
	s.fieldMap["Id"] = s.ID
	s.fieldMap["Account__c"] = s.AccountC
	s.fieldMap["Active__c"] = s.ActiveC
}

func (s sfCadenceDetail) clone(db *gorm.DB) sfCadenceDetail {
	s.sfCadenceDetailDo.ReplaceConnPool(db.Statement.ConnPool)
	return s
}

func (s sfCadenceDetail) replaceDB(db *gorm.DB) sfCadenceDetail {
	s.sfCadenceDetailDo.ReplaceDB(db)
	return s
}

type sfCadenceDetailDo struct{ gen.DO }

type ISfCadenceDetailDo interface {
	gen.SubQuery
	Debug() ISfCadenceDetailDo
	WithContext(ctx context.Context) ISfCadenceDetailDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ISfCadenceDetailDo
	WriteDB() ISfCadenceDetailDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ISfCadenceDetailDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ISfCadenceDetailDo
	Not(conds ...gen.Condition) ISfCadenceDetailDo
	Or(conds ...gen.Condition) ISfCadenceDetailDo
	Select(conds ...field.Expr) ISfCadenceDetailDo
	Where(conds ...gen.Condition) ISfCadenceDetailDo
	Order(conds ...field.Expr) ISfCadenceDetailDo
	Distinct(cols ...field.Expr) ISfCadenceDetailDo
	Omit(cols ...field.Expr) ISfCadenceDetailDo
	Join(table schema.Tabler, on ...field.Expr) ISfCadenceDetailDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ISfCadenceDetailDo
	RightJoin(table schema.Tabler, on ...field.Expr) ISfCadenceDetailDo
	Group(cols ...field.Expr) ISfCadenceDetailDo
	Having(conds ...gen.Condition) ISfCadenceDetailDo
	Limit(limit int) ISfCadenceDetailDo
	Offset(offset int) ISfCadenceDetailDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ISfCadenceDetailDo
	Unscoped() ISfCadenceDetailDo
	Create(values ...*model.SfCadenceDetail) error
	CreateInBatches(values []*model.SfCadenceDetail, batchSize int) error
	Save(values ...*model.SfCadenceDetail) error
	First() (*model.SfCadenceDetail, error)
	Take() (*model.SfCadenceDetail, error)
	Last() (*model.SfCadenceDetail, error)
	Find() ([]*model.SfCadenceDetail, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.SfCadenceDetail, err error)
	FindInBatches(result *[]*model.SfCadenceDetail, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.SfCadenceDetail) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ISfCadenceDetailDo
	Assign(attrs ...field.AssignExpr) ISfCadenceDetailDo
	Joins(fields ...field.RelationField) ISfCadenceDetailDo
	Preload(fields ...field.RelationField) ISfCadenceDetailDo
	FirstOrInit() (*model.SfCadenceDetail, error)
	FirstOrCreate() (*model.SfCadenceDetail, error)
	FindByPage(offset int, limit int) (result []*model.SfCadenceDetail, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ISfCadenceDetailDo
	UnderlyingDB() *gorm.DB
	schema.Tabler

	FilterWithColumn(column string, value string) (result model.SfCadenceDetail, err error)
}

// SELECT * FROM @@table WHERE @@column=@value
func (s sfCadenceDetailDo) FilterWithColumn(column string, value string) (result model.SfCadenceDetail, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, value)
	generateSQL.WriteString("SELECT * FROM sf_cadence_details WHERE " + s.Quote(column) + "=? ")

	var executeSQL *gorm.DB
	executeSQL = s.UnderlyingDB().Raw(generateSQL.String(), params...).Take(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

func (s sfCadenceDetailDo) Debug() ISfCadenceDetailDo {
	return s.withDO(s.DO.Debug())
}

func (s sfCadenceDetailDo) WithContext(ctx context.Context) ISfCadenceDetailDo {
	return s.withDO(s.DO.WithContext(ctx))
}

func (s sfCadenceDetailDo) ReadDB() ISfCadenceDetailDo {
	return s.Clauses(dbresolver.Read)
}

func (s sfCadenceDetailDo) WriteDB() ISfCadenceDetailDo {
	return s.Clauses(dbresolver.Write)
}

func (s sfCadenceDetailDo) Session(config *gorm.Session) ISfCadenceDetailDo {
	return s.withDO(s.DO.Session(config))
}

func (s sfCadenceDetailDo) Clauses(conds ...clause.Expression) ISfCadenceDetailDo {
	return s.withDO(s.DO.Clauses(conds...))
}

func (s sfCadenceDetailDo) Returning(value interface{}, columns ...string) ISfCadenceDetailDo {
	return s.withDO(s.DO.Returning(value, columns...))
}

func (s sfCadenceDetailDo) Not(conds ...gen.Condition) ISfCadenceDetailDo {
	return s.withDO(s.DO.Not(conds...))
}

func (s sfCadenceDetailDo) Or(conds ...gen.Condition) ISfCadenceDetailDo {
	return s.withDO(s.DO.Or(conds...))
}

func (s sfCadenceDetailDo) Select(conds ...field.Expr) ISfCadenceDetailDo {
	return s.withDO(s.DO.Select(conds...))
}

func (s sfCadenceDetailDo) Where(conds ...gen.Condition) ISfCadenceDetailDo {
	return s.withDO(s.DO.Where(conds...))
}

func (s sfCadenceDetailDo) Order(conds ...field.Expr) ISfCadenceDetailDo {
	return s.withDO(s.DO.Order(conds...))
}

func (s sfCadenceDetailDo) Distinct(cols ...field.Expr) ISfCadenceDetailDo {
	return s.withDO(s.DO.Distinct(cols...))
}

func (s sfCadenceDetailDo) Omit(cols ...field.Expr) ISfCadenceDetailDo {
	return s.withDO(s.DO.Omit(cols...))
}

func (s sfCadenceDetailDo) Join(table schema.Tabler, on ...field.Expr) ISfCadenceDetailDo {
	return s.withDO(s.DO.Join(table, on...))
}

func (s sfCadenceDetailDo) LeftJoin(table schema.Tabler, on ...field.Expr) ISfCadenceDetailDo {
	return s.withDO(s.DO.LeftJoin(table, on...))
}

func (s sfCadenceDetailDo) RightJoin(table schema.Tabler, on ...field.Expr) ISfCadenceDetailDo {
	return s.withDO(s.DO.RightJoin(table, on...))
}

func (s sfCadenceDetailDo) Group(cols ...field.Expr) ISfCadenceDetailDo {
	return s.withDO(s.DO.Group(cols...))
}

func (s sfCadenceDetailDo) Having(conds ...gen.Condition) ISfCadenceDetailDo {
	return s.withDO(s.DO.Having(conds...))
}

func (s sfCadenceDetailDo) Limit(limit int) ISfCadenceDetailDo {
	return s.withDO(s.DO.Limit(limit))
}

func (s sfCadenceDetailDo) Offset(offset int) ISfCadenceDetailDo {
	return s.withDO(s.DO.Offset(offset))
}

func (s sfCadenceDetailDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ISfCadenceDetailDo {
	return s.withDO(s.DO.Scopes(funcs...))
}

func (s sfCadenceDetailDo) Unscoped() ISfCadenceDetailDo {
	return s.withDO(s.DO.Unscoped())
}

func (s sfCadenceDetailDo) Create(values ...*model.SfCadenceDetail) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Create(values)
}

func (s sfCadenceDetailDo) CreateInBatches(values []*model.SfCadenceDetail, batchSize int) error {
	return s.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (s sfCadenceDetailDo) Save(values ...*model.SfCadenceDetail) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Save(values)
}

func (s sfCadenceDetailDo) First() (*model.SfCadenceDetail, error) {
	if result, err := s.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.SfCadenceDetail), nil
	}
}

func (s sfCadenceDetailDo) Take() (*model.SfCadenceDetail, error) {
	if result, err := s.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.SfCadenceDetail), nil
	}
}

func (s sfCadenceDetailDo) Last() (*model.SfCadenceDetail, error) {
	if result, err := s.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.SfCadenceDetail), nil
	}
}

func (s sfCadenceDetailDo) Find() ([]*model.SfCadenceDetail, error) {
	result, err := s.DO.Find()
	return result.([]*model.SfCadenceDetail), err
}

func (s sfCadenceDetailDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.SfCadenceDetail, err error) {
	buf := make([]*model.SfCadenceDetail, 0, batchSize)
	err = s.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (s sfCadenceDetailDo) FindInBatches(result *[]*model.SfCadenceDetail, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return s.DO.FindInBatches(result, batchSize, fc)
}

func (s sfCadenceDetailDo) Attrs(attrs ...field.AssignExpr) ISfCadenceDetailDo {
	return s.withDO(s.DO.Attrs(attrs...))
}

func (s sfCadenceDetailDo) Assign(attrs ...field.AssignExpr) ISfCadenceDetailDo {
	return s.withDO(s.DO.Assign(attrs...))
}

func (s sfCadenceDetailDo) Joins(fields ...field.RelationField) ISfCadenceDetailDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Joins(_f))
	}
	return &s
}

func (s sfCadenceDetailDo) Preload(fields ...field.RelationField) ISfCadenceDetailDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Preload(_f))
	}
	return &s
}

func (s sfCadenceDetailDo) FirstOrInit() (*model.SfCadenceDetail, error) {
	if result, err := s.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.SfCadenceDetail), nil
	}
}

func (s sfCadenceDetailDo) FirstOrCreate() (*model.SfCadenceDetail, error) {
	if result, err := s.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.SfCadenceDetail), nil
	}
}

func (s sfCadenceDetailDo) FindByPage(offset int, limit int) (result []*model.SfCadenceDetail, count int64, err error) {
	result, err = s.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = s.Offset(-1).Limit(-1).Count()
	return
}

func (s sfCadenceDetailDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = s.Count()
	if err != nil {
		return
	}

	err = s.Offset(offset).Limit(limit).Scan(result)
	return
}

func (s sfCadenceDetailDo) Scan(result interface{}) (err error) {
	return s.DO.Scan(result)
}

func (s sfCadenceDetailDo) Delete(models ...*model.SfCadenceDetail) (result gen.ResultInfo, err error) {
	return s.DO.Delete(models)
}

func (s *sfCadenceDetailDo) withDO(do gen.Dao) *sfCadenceDetailDo {
	s.DO = *do.(*gen.DO)
	return s
}
