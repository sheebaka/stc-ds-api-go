// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"strings"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/stc-ds-databricks-go/orm/model"
)

func newSfAccount(db *gorm.DB, opts ...gen.DOOption) sfAccount {
	_sfAccount := sfAccount{}

	_sfAccount.sfAccountDo.UseDB(db, opts...)
	_sfAccount.sfAccountDo.UseModel(&model.SfAccount{})

	tableName := _sfAccount.sfAccountDo.TableName()
	_sfAccount.ALL = field.NewAsterisk(tableName)
	_sfAccount.ID = field.NewString(tableName, "Id")
	_sfAccount.DOTNumberC = field.NewString(tableName, "DOT_Number__c")
	_sfAccount.Name = field.NewString(tableName, "Name")
	_sfAccount.CRMAccountNumberC = field.NewString(tableName, "CRM_Account_Number__c")

	_sfAccount.fillFieldMap()

	return _sfAccount
}

type sfAccount struct {
	sfAccountDo

	ALL               field.Asterisk
	ID                field.String
	DOTNumberC        field.String
	Name              field.String
	CRMAccountNumberC field.String

	fieldMap map[string]field.Expr
}

func (s sfAccount) Table(newTableName string) *sfAccount {
	s.sfAccountDo.UseTable(newTableName)
	return s.updateTableName(newTableName)
}

func (s sfAccount) As(alias string) *sfAccount {
	s.sfAccountDo.DO = *(s.sfAccountDo.As(alias).(*gen.DO))
	return s.updateTableName(alias)
}

func (s *sfAccount) updateTableName(table string) *sfAccount {
	s.ALL = field.NewAsterisk(table)
	s.ID = field.NewString(table, "Id")
	s.DOTNumberC = field.NewString(table, "DOT_Number__c")
	s.Name = field.NewString(table, "Name")
	s.CRMAccountNumberC = field.NewString(table, "CRM_Account_Number__c")

	s.fillFieldMap()

	return s
}

func (s *sfAccount) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := s.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (s *sfAccount) fillFieldMap() {
	s.fieldMap = make(map[string]field.Expr, 4)
	s.fieldMap["Id"] = s.ID
	s.fieldMap["DOT_Number__c"] = s.DOTNumberC
	s.fieldMap["Name"] = s.Name
	s.fieldMap["CRM_Account_Number__c"] = s.CRMAccountNumberC
}

func (s sfAccount) clone(db *gorm.DB) sfAccount {
	s.sfAccountDo.ReplaceConnPool(db.Statement.ConnPool)
	return s
}

func (s sfAccount) replaceDB(db *gorm.DB) sfAccount {
	s.sfAccountDo.ReplaceDB(db)
	return s
}

type sfAccountDo struct{ gen.DO }

type ISfAccountDo interface {
	gen.SubQuery
	Debug() ISfAccountDo
	WithContext(ctx context.Context) ISfAccountDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ISfAccountDo
	WriteDB() ISfAccountDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ISfAccountDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ISfAccountDo
	Not(conds ...gen.Condition) ISfAccountDo
	Or(conds ...gen.Condition) ISfAccountDo
	Select(conds ...field.Expr) ISfAccountDo
	Where(conds ...gen.Condition) ISfAccountDo
	Order(conds ...field.Expr) ISfAccountDo
	Distinct(cols ...field.Expr) ISfAccountDo
	Omit(cols ...field.Expr) ISfAccountDo
	Join(table schema.Tabler, on ...field.Expr) ISfAccountDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ISfAccountDo
	RightJoin(table schema.Tabler, on ...field.Expr) ISfAccountDo
	Group(cols ...field.Expr) ISfAccountDo
	Having(conds ...gen.Condition) ISfAccountDo
	Limit(limit int) ISfAccountDo
	Offset(offset int) ISfAccountDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ISfAccountDo
	Unscoped() ISfAccountDo
	Create(values ...*model.SfAccount) error
	CreateInBatches(values []*model.SfAccount, batchSize int) error
	Save(values ...*model.SfAccount) error
	First() (*model.SfAccount, error)
	Take() (*model.SfAccount, error)
	Last() (*model.SfAccount, error)
	Find() ([]*model.SfAccount, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.SfAccount, err error)
	FindInBatches(result *[]*model.SfAccount, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.SfAccount) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ISfAccountDo
	Assign(attrs ...field.AssignExpr) ISfAccountDo
	Joins(fields ...field.RelationField) ISfAccountDo
	Preload(fields ...field.RelationField) ISfAccountDo
	FirstOrInit() (*model.SfAccount, error)
	FirstOrCreate() (*model.SfAccount, error)
	FindByPage(offset int, limit int) (result []*model.SfAccount, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ISfAccountDo
	UnderlyingDB() *gorm.DB
	schema.Tabler

	FilterWithColumn(column string, value string) (result model.SfAccount, err error)
}

// SELECT * FROM @@table WHERE @@column=@value
func (s sfAccountDo) FilterWithColumn(column string, value string) (result model.SfAccount, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, value)
	generateSQL.WriteString("SELECT * FROM sf_account WHERE " + s.Quote(column) + "=? ")

	var executeSQL *gorm.DB
	executeSQL = s.UnderlyingDB().Raw(generateSQL.String(), params...).Take(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

func (s sfAccountDo) Debug() ISfAccountDo {
	return s.withDO(s.DO.Debug())
}

func (s sfAccountDo) WithContext(ctx context.Context) ISfAccountDo {
	return s.withDO(s.DO.WithContext(ctx))
}

func (s sfAccountDo) ReadDB() ISfAccountDo {
	return s.Clauses(dbresolver.Read)
}

func (s sfAccountDo) WriteDB() ISfAccountDo {
	return s.Clauses(dbresolver.Write)
}

func (s sfAccountDo) Session(config *gorm.Session) ISfAccountDo {
	return s.withDO(s.DO.Session(config))
}

func (s sfAccountDo) Clauses(conds ...clause.Expression) ISfAccountDo {
	return s.withDO(s.DO.Clauses(conds...))
}

func (s sfAccountDo) Returning(value interface{}, columns ...string) ISfAccountDo {
	return s.withDO(s.DO.Returning(value, columns...))
}

func (s sfAccountDo) Not(conds ...gen.Condition) ISfAccountDo {
	return s.withDO(s.DO.Not(conds...))
}

func (s sfAccountDo) Or(conds ...gen.Condition) ISfAccountDo {
	return s.withDO(s.DO.Or(conds...))
}

func (s sfAccountDo) Select(conds ...field.Expr) ISfAccountDo {
	return s.withDO(s.DO.Select(conds...))
}

func (s sfAccountDo) Where(conds ...gen.Condition) ISfAccountDo {
	return s.withDO(s.DO.Where(conds...))
}

func (s sfAccountDo) Order(conds ...field.Expr) ISfAccountDo {
	return s.withDO(s.DO.Order(conds...))
}

func (s sfAccountDo) Distinct(cols ...field.Expr) ISfAccountDo {
	return s.withDO(s.DO.Distinct(cols...))
}

func (s sfAccountDo) Omit(cols ...field.Expr) ISfAccountDo {
	return s.withDO(s.DO.Omit(cols...))
}

func (s sfAccountDo) Join(table schema.Tabler, on ...field.Expr) ISfAccountDo {
	return s.withDO(s.DO.Join(table, on...))
}

func (s sfAccountDo) LeftJoin(table schema.Tabler, on ...field.Expr) ISfAccountDo {
	return s.withDO(s.DO.LeftJoin(table, on...))
}

func (s sfAccountDo) RightJoin(table schema.Tabler, on ...field.Expr) ISfAccountDo {
	return s.withDO(s.DO.RightJoin(table, on...))
}

func (s sfAccountDo) Group(cols ...field.Expr) ISfAccountDo {
	return s.withDO(s.DO.Group(cols...))
}

func (s sfAccountDo) Having(conds ...gen.Condition) ISfAccountDo {
	return s.withDO(s.DO.Having(conds...))
}

func (s sfAccountDo) Limit(limit int) ISfAccountDo {
	return s.withDO(s.DO.Limit(limit))
}

func (s sfAccountDo) Offset(offset int) ISfAccountDo {
	return s.withDO(s.DO.Offset(offset))
}

func (s sfAccountDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ISfAccountDo {
	return s.withDO(s.DO.Scopes(funcs...))
}

func (s sfAccountDo) Unscoped() ISfAccountDo {
	return s.withDO(s.DO.Unscoped())
}

func (s sfAccountDo) Create(values ...*model.SfAccount) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Create(values)
}

func (s sfAccountDo) CreateInBatches(values []*model.SfAccount, batchSize int) error {
	return s.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (s sfAccountDo) Save(values ...*model.SfAccount) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Save(values)
}

func (s sfAccountDo) First() (*model.SfAccount, error) {
	if result, err := s.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.SfAccount), nil
	}
}

func (s sfAccountDo) Take() (*model.SfAccount, error) {
	if result, err := s.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.SfAccount), nil
	}
}

func (s sfAccountDo) Last() (*model.SfAccount, error) {
	if result, err := s.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.SfAccount), nil
	}
}

func (s sfAccountDo) Find() ([]*model.SfAccount, error) {
	result, err := s.DO.Find()
	return result.([]*model.SfAccount), err
}

func (s sfAccountDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.SfAccount, err error) {
	buf := make([]*model.SfAccount, 0, batchSize)
	err = s.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (s sfAccountDo) FindInBatches(result *[]*model.SfAccount, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return s.DO.FindInBatches(result, batchSize, fc)
}

func (s sfAccountDo) Attrs(attrs ...field.AssignExpr) ISfAccountDo {
	return s.withDO(s.DO.Attrs(attrs...))
}

func (s sfAccountDo) Assign(attrs ...field.AssignExpr) ISfAccountDo {
	return s.withDO(s.DO.Assign(attrs...))
}

func (s sfAccountDo) Joins(fields ...field.RelationField) ISfAccountDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Joins(_f))
	}
	return &s
}

func (s sfAccountDo) Preload(fields ...field.RelationField) ISfAccountDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Preload(_f))
	}
	return &s
}

func (s sfAccountDo) FirstOrInit() (*model.SfAccount, error) {
	if result, err := s.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.SfAccount), nil
	}
}

func (s sfAccountDo) FirstOrCreate() (*model.SfAccount, error) {
	if result, err := s.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.SfAccount), nil
	}
}

func (s sfAccountDo) FindByPage(offset int, limit int) (result []*model.SfAccount, count int64, err error) {
	result, err = s.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = s.Offset(-1).Limit(-1).Count()
	return
}

func (s sfAccountDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = s.Count()
	if err != nil {
		return
	}

	err = s.Offset(offset).Limit(limit).Scan(result)
	return
}

func (s sfAccountDo) Scan(result interface{}) (err error) {
	return s.DO.Scan(result)
}

func (s sfAccountDo) Delete(models ...*model.SfAccount) (result gen.ResultInfo, err error) {
	return s.DO.Delete(models)
}

func (s *sfAccountDo) withDO(do gen.Dao) *sfAccountDo {
	s.DO = *do.(*gen.DO)
	return s
}
